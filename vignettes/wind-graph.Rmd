---
title: "Improving the graph with wind"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Improving the graph with wind}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(GeoPressureR)
library(ecmwfr)
library(raster)
library(ncdf4)
library(leaflet)
```

In this vignette, we will enhance the [basic graph](./articles/basic-graph) by adding the wind speed. This allows to defines the movement model on the airspeed (instead of groundspeed). In addition, we can extract windsupport information on the journey of the bird. 

```{r}
pam_data <- pam_read(
  pathname = system.file("extdata", package = "GeoPressureR"),
  crop_start = "2017-06-20", crop_end = "2018-05-02"
)
pam_data <- trainset_read(pam_data, pathname = system.file("extdata", package = "GeoPressureR"))
pam_data <- pam_sta(pam_data)
data("static_prob", package = "GeoPressureR")
```

## Download wind data

Wind data is available at high resolution (1hr, 0.25Â°, 37 pressure level) on [ERA5 hourly data on pressure levels](https://doi.org/10.24381/cds.bd0915c6). And this data is easily accessible through the [`ecmfr`](https://bluegreen-labs.github.io/ecmwfr) package. 
As the flight are of short duration, we suggest to download a file for each flight.

The first step is to setup-up your CDS access. You will need to create an account on [https://cds.climate.copernicus.eu/](https://cds.climate.copernicus.eu/user/register) to generate your API key and uid number. You can stored them in your `.Rprofile` with the commented code.
 
```{r, eval=F}
#Sys.setenv( cds.key="Insert_your_CDS_API_KEY_here")
#Sys.setenv( cds.user="Insert_your_CDS_UID_here")
# usethis::edit_r_environ()
cds.key <- Sys.getenv('cds.key')
cds.user <- Sys.getenv('cds.user')
wf_set_key(user = cds.user, key = cds.key, service = "cds")
```

To efficiently query only the data needed, we will sub-select the pressure level needed for each flight. We enter the [37 pressure level of ERA-5](https://confluence.ecmwf.int/display/CKB/ERA5%3A+data+documentation#ERA5:datadocumentation-Levellistings) and define the geographical area.

```{r, eval=F}
possible_pressure = c(1, 2, 3, 5, 7, 10, 20, 30, 50, 70, seq(100,250,25), seq(300,750,50), seq(775,1000,25))

area = extent(static_prob[[1]])
area = c(area@ymax, area@xmin, area@ymin, area@xmax)
```

It will be faster to send all the requests (one per flight) with `wf_request()` using `transfer = F` without waiting to get the data from one before requesting the next. These query can be very quick or sometime take a couple of hours, usually not more. You can monitor easily at [https://cds.climate.copernicus.eu/cdsapp#!/yourrequests](https://cds.climate.copernicus.eu/cdsapp#!/yourrequests) the status of your requests, delete them or download them manually if needed. 

```{r, eval=F}
req <- list()
for (i_s in seq_len(nrow(pam_data$sta)-1)){
  # Get the timeserie of the flight on a 1 hour resolution
  flight_time = seq(round(pam_data$sta$end[i_s]-30*60, units = "hours"), round(pam_data$sta$start[i_s+1]+30*60, units = "hours"), by=60*60)
  
  # Find the pressure level needed during this flight
  flight_id =  flight_time[1] <= pam_data$pressure$date & pam_data$pressure$date <=  tail(flight_time,1)
  pres_id_min = sum(!(min(pam_data$pressure$obs[flight_id]) < possible_pressure))
  pres_id_max = sum(max(pam_data$pressure$obs[flight_id]) > possible_pressure)+1
  flight_pres_id = seq(pres_id_min, min(pres_id_max,length(possible_pressure)))
  
  # Prepare the query
  request <- list(
    dataset_short_name = "reanalysis-era5-pressure-levels",
    product_type   = "reanalysis",
    format = "netcdf",
    variable = c('u_component_of_wind', 'v_component_of_wind'),
    pressure_level = possible_pressure[flight_pres_id],
    year = sort(unique(format(flight_time,'%Y'))),
    month = sort(unique(format(flight_time,'%m'))),
    day = sort(unique(format(flight_time,'%d'))),
    time = sort(unique(format(flight_time,'%H:%M'))),
    # area is specified as N, W, S, E
    area = area
  )
  # We can send the query without downloading the data. This allows to send all of them and then wait to get them back later.  
  req[[i_s]] <- wf_request(user = cds.user, request = request, transfer = F)
}
```

Define the folder where to download the data. `wf_transfer()` will download the file in the temporary folder by default.

```{r}
dir.save <- '~'
```

The following code will return the status of the request if then have not yet been processed, or return the data otherwise. I suggest to check on [https://cds.climate.copernicus.eu/cdsapp#!/yourrequests] if the request have been completed before running this code. It can take a couple of minutes to a few hours.    

```{r, eval=F}
for (i_s in seq_len(nrow(pam_data$sta)-1)){
  filename = paste0("18IC_",i_s,".nc")
  wf_transfer(url = req[[i_s]]$request_id, service = "cds", user = cds.user, path = dir.save, filename=filename)
}
```

## Create graph

We first create the graph identically to in [basic graph](./articles/basic-graph)

```{r, eval=F}
grl <- graph_create(static_prob, thr_prob_percentile = .99, thr_gs = 150)  
```


## Add wind to graph

We can compute the windspeed experienced by the bird if he had flew each possible transition (i.e. edge in the graph). Based on this windspeed and groundspeed, we also compute the airspeed. All of these are stored as complex value with the real part representing the E-W component and the imaginary part corresponding to the N-S. 

```{r, eval=F}
filename = paste0(dir.save,"/","18IC_")
grl <- graph_add_wind(grl, pressure=pam_data$pressure, filename)#, thr_as = 100)
usethis::use_data(grl, overwrite = T)
```

```{r}
data("grl", package = "GeoPressureR")
```

## Compute the edges probability

Now that the have computed the airspeed required for performing the transition of each edge, we can improve the computation of the probability by modeling the probability of airspeed rather than groundspeed. 

We first search the morphological information of the Great Reed Warbler using the [AVONET database](https://doi.org/10.6084/m9.figshare.16586228.v5). You can also overwrite any of these value if you know them. See `flight_bird()` for more details
```{r}
bird <- flight_bird("Acrocephalus arundinaceus")
speed <- seq(0,80)
prob <- flight_prob(speed, method = "power", bird = bird, low_speed_fix = 10)
plot(speed, prob, type="l", xlab="Airspeed [km/h]", ylab="Probability")
grl$p <- grl$ps * flight_prob(grl$gs, method = "power", bird = bird, low_speed_fix = 10)
```


## Output 1: Shortest path

In graph theroy, [the shortest path](https://en.wikipedia.org/wiki/Shortest_path_problem) correspond to the set of nodes whose sum of the edges weights are as small as possible. By weighting the edges with the minus of the log of the porbability, this corresponds to finding the most likely trajectory of our bird. We solve this problem with the [igraph package](https://igraph.org/r/)

```{r}
g <- graph_from_data_frame(data.frame(
  from = grl$s,
  to = grl$t,
  weight = -log(grl$p)
))
sp <- shortest_paths(g, from = paste(grl$equipement), to = paste(grl$retrival))
# Convert igraph representation to lat-lon
grl$shortest_path <- graph_path2lonlat(as.numeric(sp$vpath[[1]]$name), grl)
```


```{r}
sta_duration <- unlist(lapply(static_prob,function(x){as.numeric(difftime(metadata(x)$temporal_extent[2],metadata(x)$temporal_extent[1],units="days"))}))
leaflet() %>%
  addTiles() %>%
  addPolylines(lng = grl$shortest_path$lon, lat = grl$shortest_path$lat, opacity = 1, color = "#808080", weight = 3) %>%
  addCircles(lng = grl$shortest_path$lon, lat = grl$shortest_path$lat, opacity = 1, color = "#000", weight = sta_duration^(0.3)*10)
```


## Output 2: Proability map of stationary period

Estimating the position of the bird for each stationary period is generally the most sought-after output of tracking studies. Using the graph built, we can compute this exactly (i.e., without iterative approach such as MCMC). This problem is the same as computing the marginal distribution of a Markov process which can be solved mathematically.

```{r}
grl_marginal <- graph_marginal(grl)
```

```{r, warning=F}
li_s <- list()
l <- leaflet() %>% addTiles()
for (i_r in seq_len(length(grl_marginal))) {
  i_s <- metadata(static_prob[[i_r]])$sta_id
  info <- metadata(static_prob[[i_r]])$temporal_extent
  info_str <- paste0(i_s, " | ", info[1], "->", info[2])
  li_s <- append(li_s, info_str)
  l <- l %>%
    addRasterImage(grl_marginal[[i_r]], colors = "OrRd", opacity = 0.8, group = info_str) %>%
    addCircles(lng = grl$shortest_path$lon[i_s], lat = grl$shortest_path$lat[i_s], opacity = 1, color = "#000", weight = 10, group = info_str)
}
l %>%
  addLayersControl(
    overlayGroups = li_s,
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  hideGroup(tail(li_s, length(li_s) - 1))
```

## Output 3: Simulate path

```{r}
path <- graph_simulation(grl)
```
