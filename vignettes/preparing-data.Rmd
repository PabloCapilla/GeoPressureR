---
title: "Preparing data for trajectory modelling"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Preparing data for trajectory modelling}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette covers important pre-processing steps to ensure that modelling the trajectory with a graph is possible and successful. Firstly, we will aligned the maps of pressure and light and create a `static_prob` variable containing all the information necessary for modeling the trajectory (incl. flight info).

But before moving too quickly, we need to carefully check that pressure, light and flight duration data allow for a coherent trajectory. It is possible (even probable) that some manual editing of the pressure data labeling will be required, especially for short stopovers.

```{r setup, message=F}
library(GeoPressureR)
library(raster)
library(leaflet)
```

## Combine pressure and light probability maps

Start by loading the PAM, light and pressure data computed in the respective vignettes [Light map](./articles/light-map.html) and [Pressure map](./articles/pressure-map.html).

```{r}
data("pressure_prob", package = "GeoPressureR")
data("light_prob", package = "GeoPressureR")
pam_data <- pam_read(
  pathname = system.file("extdata", package = "GeoPressureR"),
  crop_start = "2017-06-20", crop_end = "2018-05-02"
)
pam_data <- trainset_read(pam_data, pathname = system.file("extdata", package = "GeoPressureR"))
pam_data <- pam_sta(pam_data)
```

We need to retrieve the pressure and light data for the same stationary period. Using `thr_sta_dur`, you can also specify at this stage which stationary period to include. When running the check for the first time, it is recommended to start by filtering only longer stationary periods (e.g. 5*24 hours), and when all the check below are passing, reduce gradually the threshold on stopover duration.

```{r}
thr_sta_dur = 0 # in hours
sta_pres <- unlist(lapply(pressure_prob, function(x) raster::metadata(x)$sta_id))
sta_light <- unlist(lapply(light_prob, function(x) raster::metadata(x)$sta_id))
sta_thres <- pam_data$sta$sta_id[difftime(pam_data$sta$end, pam_data$sta$start, units = "hours") > thr_sta_dur]
# Get the sta_id present on all three data sources
sta_id_keep = intersect(intersect(sta_pres,sta_light),sta_thres)
# Filter pressure and light map
pressure_prob <- pressure_prob[sta_pres %in% sta_id_keep]
light_prob <- light_prob[sta_light %in% sta_id_keep]
```

We then need to keep all the flights between consecutive stationary period separate so that we can estimate the wind support correctly.

```{r}
flight = list()
for (i_f in seq_len(length(sta_id_keep)-1)){
  from_sta_id <- sta_id_keep[i_f]
  to_sta_id <- sta_id_keep[i_f+1]
  flight[[i_f]] <- list(
    start = pam_data$sta$end[seq(from_sta_id,to_sta_id-1)],
    end = pam_data$sta$start[seq(from_sta_id+1,to_sta_id)],
    sta_id = seq(from_sta_id,to_sta_id-1)
  )
}
flight[[i_f+1]]=list()
```

We compute the static probability with the product of light and pressure probability maps, and add the flight duration in the metadata. `static_prob` is the consolidate variable containing all the information necessary to run the graph functions.

```{r}
static_prob <- mapply(function(light, pressure, flight) {
  # define static prob as the product of light and pressure prob
  static_prob <- light * pressure
  
  # replace na by zero
  # tmp <- values(static_prob)
  # tmp[is.na(tmp)] <- 0
  # values(static_prob) <- tmp
  
  # define metadata
  metadata(static_prob) <- metadata(pressure)
  metadata(static_prob)$flight <- flight
  
  # return
  static_prob
}, light_prob, pressure_prob, flight)
```

We overwrite the probability of the first and last stationary periods with the known location of the equipment/retrieval sites.

```{r}
lon_calib <- 17.05
lat_calib <- 48.9

lat <- seq(raster::ymax(static_prob[[1]]), raster::ymin(static_prob[[1]]), length.out = nrow(static_prob[[1]]) + 1)
lat <- lat[seq_len(length(lat) - 1)] + diff(lat[1:2]) / 2
lon <- seq(raster::xmin(static_prob[[1]]), raster::xmax(static_prob[[1]]), length.out = ncol(static_prob[[1]]) + 1)
lon <- lon[seq_len(length(lon) - 1)] + diff(lon[1:2]) / 2

lon_calib_id <- which.min(abs(lon_calib - lon))
lat_calib_id <- which.min(abs(lat_calib - lat))

tmp <- as.matrix(static_prob[[1]])
tmp[!is.na(tmp)] <- 0
tmp[lat_calib_id, lon_calib_id] <- 1
values(static_prob[[1]]) <- tmp

tmp <- as.matrix(static_prob[[length(static_prob)]])
tmp[!is.na(tmp)] <- 0
tmp[lat_calib_id, lon_calib_id] <- 1
values(static_prob[[length(static_prob)]]) <- tmp
```


```{r, eval = F}
path <- geopressure_map2path(static_prob)
path$lat[3] <- path$lat[3] + .25
path$lat[5] <- path$lat[5] + .25
path$lat[27] <- path$lat[27] - .5
static_timeserie <- geopressure_ts_path(path, pam_data$pressure)
usethis::use_data(static_timeserie, overwrite = T)
```
```{r}
data("static_timeserie", package = "GeoPressureR")
```


## Checking model input

In this second section, we will look at a few checks to perform before moving to the modelling step. These checks (#1 and #2) are performed when creating the graph `graph_create()`, but for pedagogical reason, I thought it would be better to introduce them step by step here as they will also help you to get a better sense of the specific movement/trajectory of the bird you are modeling.

In the vignette [Labelling tracks](./articles/labelling-tracks), we had already checked that the pressure timeseries measured by the geolocator are consistent with a least one location on the map (see Test #4 outlined in that vignette). But we didn't checked that these position are (1) coherent with light data, and (2) within reach of one other considering the flight duration and realistic bird flight speed. 

To help you troubleshoot the failure of check, we have developed a shiny app `GeoPressureViz` which helps you visualize the overall trajectory of the bird (see sub-section below for details). I would suggest to run `GeoPressureViz` side-by-side with the checks.

We suggest starting by selecting only long stopovers (24-48hours), as this will help to draw out the general trajectory followed by the bird, and only later adding the shorter stopovers which could raise more confusion (the best match of pressure is often completely off). This is where the flight duration can help identify a realistic trajectory.

As a general guideline, use your common sense, rather than solely on the model, to draw out the trajectory course. The model needs to give realistic trajectories, otherwise there is a labeling issue. The most regular issue I faced is a small vertical movement of the bird during a short stopover which completely throw off the estimation of pressure map. 


### GeoPressureViz 

To run the visualization, you will need to save the data in a `.RData` in your home folder (`~`). I cannot find a good way to pass variable to a shiny app instance (let me know if you have a suggestion). 

The minimum information needed is `static_prob` and `pam_data`, but to see the difference between light and pressure, you will also need to extract `light_prob` and `pressure_prob`. In addition, to visualize pre-computed pressure timeseries at some location, you can use export `pressure_timeserie` computed in the vignette [Labelling tracks](./articles/labelling-tracks)

```{r, evel = F}
geopressureviz = list(
  pam_data=pam_data,
  static_prob=static_prob,
  pressure_prob=pressure_prob,
  light_prob=light_prob,
  pressure_timeserie = static_timeserie
)
save(geopressureviz,file = "~/geopressureviz.RData")
```

```{r, eval=F}
appDir <- system.file("geopressureviz", package = "GeoPressureR")
shiny::runApp(appDir, launch.browser = getOption("browser"))
# shiny::runApp('./inst/geopressureviz', launch.browser = getOption("browser"))
```


### Check #1: Existance of position with static probability (pressure + light)

A first and easy check is that there be at least one location with a probability greater than 1 for each stationary period.

```{r}
static_prob_n <- lapply(static_prob, function(x) {
  probt <- raster::as.matrix(x)
  probt[is.na(probt)] <- 0
  probt / sum(probt, na.rm = T)
})
tmp <- unlist(lapply(static_prob_n, sum)) == 0
if (any(tmp)) {
  warning(paste0("The `static_prob` provided has a probability map equal to ",
                 "zero for the stationay period: ", which(tmp)))
}
```


### Check #2: Presence of at least one transition (pressure+light+flight)

Secondly, we check that there always be at least one possible transition from one stationary period to the next. 

```{r}
for (i_s in seq_len(length(static_prob) - 1)) {
  cur <- as.matrix(static_prob[[i_s]]) > 0
  cur[is.na(cur)] <- F
  nex <- as.matrix(static_prob[[i_s + 1]]) > 0
  nex[is.na(nex)] <- F
  
  mtf <- metadata(static_prob[[i_s]])
  flight_duration <- as.numeric(sum(difftime(mtf$flight$end,mtf$flight$start,unit="hours"))) # hours
  resolution <- mean(res(static_prob[[1]])) * 111 # assuming 1Â°= 111km
  thr_gs <- 150 # Assuming a max groundspeed of 150km/h

  # Check possible position at next stationary period
  possible_next <- (EBImage::distmap(!cur) * resolution / flight_duration) < thr_gs

  if (sum(possible_next & nex) == 0) {
    stop(paste("There are no possible transition from stationary period", i_s, "to", i_s + 1, ". Check part 1 process (light and pressure)", sep = " "))
  }
}
```


### Check #3: Visual inspection

This third check is the most important yet also the most complex. We check that the probability map is coherent with the flight distance from the previous location. The distance is computed based on an assumed average groundspeed. Birds can fly with a groundspeed up to 120-150 km/h (with wind support) although their usual average is around 40km/h. We iteratively plot the most likely position (black dot) based on the static probability contained within flight distance from the previous most likely position (green dot). 

Note the following key elements to correctly understand this figure. 
Firstly, birds can fly in zig-zag patterns, meaning that the total distance possible (green circle) might be greater than the actual distance from the previous stationary period (distance green to black).

Secondly, this visualization only accounts for the lag-1 movement, thus it chooses the most likely position (black dot) independently from its overall coherence with the trajectory. This typically happens for short stationary periods where the pressure match is slightly better in a different place than where the bird went. In thoses cases the visualization is wrong on the location (e.g., sending the bird north while it should be migrating south), but try to see where you can draw a path which seems coherent. In the example we use below, this happens at stationary period 14. The Great Reed Warbler was moving south towards Burkina Faso or Ghana, but a slightly more likely position occurs in Algeria. It is worth checking the pressure timeseries to see whether manual editing could change this. 


```{r, warning=F, results = 'asis'}
li_s <- list()
l <- leaflet() %>% addTiles()
speed_thr = 100
for (i_r in seq_len(length(static_prob))) {
  mt <- metadata(static_prob[[i_r]])
  
  if ( i_r > 1 ){
    mtf <- metadata(static_prob[[i_r-1]])
    flight_duration <- as.numeric(sum(difftime(mtf$flight$end,mtf$flight$start,unit="hours")))
    info_str <- paste0(mt$sta_id, " | ", format(mt$temporal_extent[1],"%d-%b %H:%M"), "->", format(mt$temporal_extent[2],"%d-%b %H:%M"), " | ", round(flight_duration),"hrs")
    max_dist <- flight_duration*speed_thr*1000
  } else{
    info_str <- paste0(mt$sta_id, " | ", mt$temporal_extent[1], "->", mt$temporal_extent[2])
  }
    
  l <- l %>% 
    addRasterImage(static_prob[[i_r]], opacity = 0.8, colors = "OrRd", group = info_str) %>% 
    addCircles(lng = lon_calib, lat = lat_calib, opacity = 1, color = "red", weight = 10, group = info_str)
  
  tmp <- as.data.frame(static_prob[[i_r]], xy = T)

  if ( i_r > 1 ){
    l <- l %>% 
      addCircles(lng = lon0, lat = lat0, opacity = 1, color = "green", weight = 10, group = info_str) %>% 
      addCircles(lng = lon0, lat = lat0, opacity = 1, color = "green", radius = max_dist, group = info_str, fillOpacity=0, weight = 2)
    id <- geosphere::distGeo(c(lon0, lat0), cbind(tmp$x,tmp$y)) > max_dist
    tmp$layer[id] <- 0
  }
  
  # find the max value of probability
  lon <- tmp$x[which.max(tmp$layer)]
  lat <- tmp$y[which.max(tmp$layer)]
  
  l <- l %>%
    addCircles(lng = lon, lat = lat, opacity = 1, color = "black", weight = 10, group = info_str)
  
  lon0 <- lon
  lat0 <- lat
  li_s <- append(li_s, info_str)
}

l %>%
  addLayersControl(
    overlayGroups = li_s,
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  hideGroup(tail(li_s, length(li_s) - 1))
```

Some animated figures might be helpful too.

```{r, animation.hook="gifski", eval=F}
library(gifski)
raster::animate(brick(static_prob), n = 1)
```

```{r, eval=F}
library(ggplot2)
library(gganimate)
dfb <- do.call("rbind", lapply(static_prob, function(x) {
  mt <- metadata(x)
  df <- as.data.frame(x, xy = T)
  df$sta_id <- mt$sta_id
  df$extend_sample <- mt$extend_sample
  df$next_flight_duration <- mt$next_flight_duration
  df
}))

dfb %>%
  ggplot() +
  geom_raster(aes(x = x, y = y, fill = layer)) +
  transition_time(sta_id)
```




## Export static probability

To improve computational costs of creation of graph, it might be helpful to first run the model on a downscale resolution (`fact > 1`) with the code below. We didn't used this in our example.

```{r, eval=F}
static_prob <- lapply(static_prob, function(raster) {
  raster_ds <- aggregate(raster, fact = 1, fun = max, na.rm = T, expand = T)
  # keep metadata
  metadata(raster_ds) <- metadata(raster)
  return(raster_ds)
})
```

Now that all the checks are completed, we can export the data generated and start the modeling, outlined in the vignette [Basic graph](./articles/basic-graph).

```{r, eval=F}
usethis::use_data(static_prob, overwrite = T)
```
