---
title: "Preparing data for trajectory modelling"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Preparing data for trajectory modelling}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette covers the combination of pressure and light data as well as important checks which should be performed to ensure that the modeling with a graph can succeed. 

So far, we have check that the pressure timeseries measure on the bird is consistent with a least one location on the map with the vignette [Labelling tracks](./articles/labelling-tracks). Make sure that the test 4 was carefully checked before running this vignette. 

In this vignette, we will check that pressure, light and flight duration allow for a coherent trajectory. It is quite likely that some manual editing of the labeling of the pressure data will still be required, especially on the short stopover.

We suggest to start selecting only long stopover (24-48hours), as this will help you to see the general trajectory of your birds. And only after, we can add the shorter ones which might be a bit confusing at first (best match can be completely off). But this is where flight duration will help you get realistic trajectory.

As a general guideline, always use your common sense on where the bird was rather than letting the model guide its course. The model needs to give realistic trajectory, otherwise, there is a labeling issue. A small vertical movement of the bird in a stopover can completely through off the estimation. 

```{r setup, message=F}
library(GeoPressureR)
library(raster)
library(leaflet)
```

## Load data

Let starte by loading the light and pressure data computed in the vignette [Light map](./articles/light-map.html) and [Pressure map](./articles/pressure-map.html) respectively.

```{r}
data("pressure_prob", package = "GeoPressureR")
data("light_prob", package = "GeoPressureR")
pam_data <- pam_read(
  pathname = system.file("extdata", package = "GeoPressureR"),
  crop_start = "2017-06-20", crop_end = "2018-05-02"
)
pam_data <- trainset_read(pam_data, pathname = system.file("extdata", package = "GeoPressureR"))
pam_data <- pam_sta(pam_data)
```

## Combine pressure and light probabibility maps

In this step, we need to get the pressure and light data for the same stationary period. There are three source of data to overlap, the last one (`sta_id_keep`) is where you can choose to modeling on only part of the data. It is easier to start keeping longer stationary period and then reduce the threshold on duration.

```{r}
sta_pres <- unlist(lapply(pressure_prob, function(x) raster::metadata(x)$sta_id))
sta_light <- unlist(lapply(light_prob, function(x) raster::metadata(x)$sta_id))
sta_thres <- pam_data$sta$sta_id[difftime(pam_data$sta$end, pam_data$sta$start, units = "hours") > 0]
# Get the sta_id present on all three data source
sta_id_keep = intersect(intersect(sta_pres,sta_light),sta_thres)
# filter pressure and light map
pressure_prob <- pressure_prob[sta_pres %in% sta_id_keep]
light_prob <- light_prob[sta_light %in% sta_id_keep]
```

We then need to keep all the flight between each stationary period separately so that we can estimate the wind support correctly.

```{r}
flight = list()
for (i_f in seq_len(length(sta_id_keep)-1)){
  from_sta_id <- sta_id_keep[i_f]
  to_sta_id <- sta_id_keep[i_f+1]
  flight[[i_f]] <- list(
    start = pam_data$sta$end[seq(from_sta_id,to_sta_id-1)],
    end = pam_data$sta$start[seq(from_sta_id+1,to_sta_id)],
    sta_id = seq(from_sta_id,to_sta_id-1)
  )
}
flight[[i_f+1]]=list()
```

Compute the static probability with the product of light and pressure probability map. We also add the flight duration in the metadata

```{r}
static_prob <- mapply(function(light, pressure, flight) {
  # define static prob as the product of light and pressure prob
  static_prob <- light * pressure
  
  # replace na by zero
  # tmp <- values(static_prob)
  # tmp[is.na(tmp)] <- 0
  # values(static_prob) <- tmp
  
  # define metadata
  metadata(static_prob) <- metadata(pressure)
  metadata(static_prob)$flight <- flight
  
  # return
  static_prob
}, light_prob, pressure_prob, flight)
```

Overwrite probability of the first and last stationary period with the known location of the equipment/retrieval site.

```{r}
lon_calib <- 17.05
lat_calib <- 48.9

lat <- seq(raster::ymax(static_prob[[1]]), raster::ymin(static_prob[[1]]), length.out = nrow(static_prob[[1]]) + 1)
lat <- lat[seq_len(length(lat) - 1)] + diff(lat[1:2]) / 2
lon <- seq(raster::xmin(static_prob[[1]]), raster::xmax(static_prob[[1]]), length.out = ncol(static_prob[[1]]) + 1)
lon <- lon[seq_len(length(lon) - 1)] + diff(lon[1:2]) / 2

lon_calib_id <- which.min(abs(lon_calib - lon))
lat_calib_id <- which.min(abs(lat_calib - lat))

tmp <- as.matrix(static_prob[[1]])
tmp[!is.na(tmp)] <- 0
tmp[lat_calib_id, lon_calib_id] <- 1
values(static_prob[[1]]) <- tmp

tmp <- as.matrix(static_prob[[length(static_prob)]])
tmp[!is.na(tmp)] <- 0
tmp[lat_calib_id, lon_calib_id] <- 1
values(static_prob[[length(static_prob)]]) <- tmp
```



## Checking model input

In this section, we will look at a few check to perform before moving to the modeling step.

### Check 1: At least one position exist

A first and easy check is that there is always at least one location with probability greater than one that exists at each stationary period.

```{r}
for (i_s in seq_len(length(static_prob))) {
  if (sum(values(static_prob[[i_s]]), na.rm = T) == 0) {
    stop(paste("Probability map of stationary period", i_s, "is null. Check part 1 process (light and pressure)", sep = " "))
  }
}
```

### Check 2: At least one transition

Secondly, we can check that there are always at least one transition possible from one stationary period to the next. 

```{r}
for (i_s in seq_len(length(static_prob) - 1)) {
  cur <- as.matrix(static_prob[[i_s]]) > 0
  cur[is.na(cur)] <- F
  nex <- as.matrix(static_prob[[i_s + 1]]) > 0
  nex[is.na(nex)] <- F
  
  mtf <- metadata(static_prob[[i_s]])
  flight_duration <- as.numeric(sum(difftime(mtf$flight$end,mtf$flight$start,unit="hours"))) # hours
  resolution <- mean(res(static_prob[[1]])) * 111 # assuming 1Â°= 111km
  thr_gs <- 150 # Assuming a max groundspeed of 150km/h

  # Check possible position at next stationary period
  possible_next <- (EBImage::distmap(!cur) * resolution / flight_duration) < thr_gs

  if (sum(possible_next & nex) == 0) {
    stop(paste("There are no possible transition from stationary period", i_s, "to", i_s + 1, ". Check part 1 process (light and pressure)", sep = " "))
  }
}
```


### Check 3: Visual inspection

This second check is the most important and can be slight more complicated to performed correctly. We will check that the proabbility map is coherent with the flight distance from the previous location. The distance is computed based on an assumed average groundspeed. Birds can fly with a groundspeed up to 120-150 km/h (with wind support) but usually the average is 40km/h. We will iteratively plot at the most likely position (black dot) from the static probability contains within the distance of flight from the previous most likely position (green dot). 

Some key element to correctly understand/check this figure. 
Firstly, bird can fly in "zig-zag", meaning that the total distance possible (green circle) might be much larger than the actual distance from previous stationary period (distance green to black).

Secondly, this visualization only account for the lag-1 movement, thus, it will choose the most likely position (black dot) independently than if it this is overall coherent with the trajectory. This typically happens for short stationary period where the match of pressure is slightly better at another place than where the bird went. The visualization become completely wrong on the location (e.g., sending the bird north while it's suppose to migrate south). Don't worry about this, just try to see that you can draw a path which seems coherent. This happen at stationary period 14 in this example. The great reed warbler was moving south to Burkina Faso or Ghana, but a slight more likely position occur in Algeria. It is worth checking the pressure timeserie to see if something can be improve there. 


```{r, warning=F, results = 'asis'}
li_s <- list()
l <- leaflet() %>% addTiles()
speed_thr = 100
for (i_r in seq_len(length(static_prob))) {
  mt <- metadata(static_prob[[i_r]])
  
  if ( i_r > 1 ){
    mtf <- metadata(static_prob[[i_r-1]])
    flight_duration <- as.numeric(sum(difftime(mtf$flight$end,mtf$flight$start,unit="hours")))
    info_str <- paste0(mt$sta_id, " | ", mt$temporal_extent[1], "->", mt$temporal_extent[2], " | ",flight_duration)
    max_dist <- flight_duration*speed_thr*1000
  } else{
    info_str <- paste0(mt$sta_id, " | ", mt$temporal_extent[1], "->", mt$temporal_extent[2])
  }
    
  l <- l %>% 
    addRasterImage(static_prob[[i_r]], opacity = 0.8, colors = "OrRd", group = info_str) %>% 
    addCircles(lng = lon_calib, lat = lat_calib, opacity = 1, color = "red", weight = 10, group = info_str)
  
  tmp <- as.data.frame(static_prob[[i_r]], xy = T)

  if ( i_r > 1 ){
    l <- l %>% 
      addCircles(lng = lon0, lat = lat0, opacity = 1, color = "green", weight = 10, group = info_str) %>% 
      addCircles(lng = lon0, lat = lat0, opacity = 1, color = "green", radius = max_dist, group = info_str, fillOpacity=0, weight = 2)
    id <- geosphere::distGeo(c(lon0, lat0), cbind(tmp$x,tmp$y)) > max_dist
    tmp$layer[id] <- 0
  }
  
  # find the max value of probability
  lon <- tmp$x[which.max(tmp$layer)]
  lat <- tmp$y[which.max(tmp$layer)]
  
  l <- l %>%
    addCircles(lng = lon, lat = lat, opacity = 1, color = "black", weight = 10, group = info_str)
  
  lon0 <- lon
  lat0 <- lat
  li_s <- append(li_s, info_str)
}

l %>%
  addLayersControl(
    overlayGroups = li_s,
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  hideGroup(tail(li_s, length(li_s) - 1))
```

Some animated figure might be helpful too.

```{r, animation.hook="gifski", eval=F}
library(gifski)
raster::animate(brick(static_prob), n = 1)
```

```{r, eval=F}
library(ggplot2)
library(gganimate)
dfb <- do.call("rbind", lapply(static_prob, function(x) {
  mt <- metadata(x)
  df <- as.data.frame(x, xy = T)
  df$sta_id <- mt$sta_id
  df$extend_sample <- mt$extend_sample
  df$next_flight_duration <- mt$next_flight_duration
  df
}))

dfb %>%
  ggplot() +
  geom_raster(aes(x = x, y = y, fill = layer)) +
  transition_time(sta_id)
```




## Export static probability

It might be useful to first run the model on a downscale map to improve computational cost. We won't need it for this example.

```{r, eval=F}
static_prob <- lapply(static_prob, function(raster) {
  raster_ds <- aggregate(raster, fact = 1, fun = max, na.rm = T, expand = T)
  # keep metadata
  metadata(raster_ds) <- metadata(raster)
  # return
  raster_ds
})
```

Now that all the check are completed, we can export the data generated and move to the modeling. 

```{r, eval=F}
usethis::use_data(static_prob, overwrite = T)
```
